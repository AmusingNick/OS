
操作系统――精髓与设计原理之进程管理读书报告  一、进程管理主要内容概述  现代操作系统最基础的任务就是进程管理。操作系统必须为进程分配资源，使进程间可以交换信息，保护各个进程的资源不被其他进程占有，并且使进程可以同步。为了达到这些要求，操作系统必须为每一个进程维护一个数据结构，这个数据结构描述进程的状态和资源所以权，这样才能让操作系统进行进程控制。  在单处理躲到程序系统中，多个进程的执行可以在同一时间交叉进行。在多处理系统中，不仅多个进程可以交叉执行，而且可以同步执行。交叉执行和同步执行都属于并发执行，这将给应用程序员和操作系统带来一些难题。  线程概念的引入，也给许多当代操作系统中的进程管理带来了困难。在一个多线程系统中，进程保留着资源所有权的属性，而多个并发执行流是执行在进程中与运行的线程。 进程描述和控制  传统操作系统的主要任务是进程管理。每一个进程在任何时候内都处于一组执行状态中的一种情况：就绪态、运行态和阻塞态。操作系统跟踪这些执行状态，并且管理进程在这些状态间的转换过程。为了达到此目的，操作系统通过相当精细的数据结构来表述每个进程。操作系统必须实现调度功能，并且为进程间的共享和同步提供便利。  线程、SMP和微内核  在许多操作系统中，传统的进程概念被分为两部分：一部分负责管理资源所有权；另一部分负责指令流的执行。一个单独的进程可包含多个线程。使用多线程的组织方法对程序的结构化和性能方面都有很大的帮助。SMP是一个拥有多处理器的计算机系统，其中的每一个处理器都可以执行所有应用程序和系统代码。SMP的组织方法增强了系统的性能和可靠性。SMP通常和多线程机制一起使用，即使没有多线程机制也能很大幅度的提高系统性能。微内核是操作系统为了减少运行在内核模式的代码量的一种设计方式，并且分析了这种方法的优点。  并发：互斥和同步  当今操作系统的两个中心主题是多道程序设计和分布式处理，并发是这两个主题的基础， 同时也是操作系统设计技术的基础。互斥是多进程（或多线程）共享代码、资源或数据的一种能力方式，这种方式是在一个时间段内只能允许一个进程访问共享对象。与互斥相关联的是同步：多个进程根据信息的交换协调它们活动的能力。支持并发最重要的机制有信号量、管程和消息传递。  并发：死锁和饥饿  死锁是这样的一种情况：一组进程中的两个或多个进程要等待该组中的其他成员完成一个操作后才能继续运行，但是没有成员可以继续。死锁是一种很难预测的现象，并且没有比较容易的通用解决方案。处理死锁的三个主要手段是预防、避免和检测。饥饿时一个准备运行的进程由于其他进程的运行而一直不能访问处理器的情况。从打的方面来说，饥饿是被当成调度问题来处理的。 进程调度  我们经常遇到两个或多个进程（例如，生产者和消费者）在逻辑上均可以运行的情况。当有多个进程就绪时，操作系统必须决定先运行哪一个。操作系统中作出这种决定的部分称作调 度程序(scheduler)，它使用的算法称作调度算法(scheduling algorithm)。                 再回到早期以磁带上的卡片映像作为输入的批处理系统时代，那时的调度算法很简单：依次运行磁带上的下一个作业。对于分时系统，则调度算法要复杂一些，因为经常有多个用户等待服务，而且同时可能存在多个批处理流（例如，保险公司理赔）。即使在个人电脑上，也可能有若干用户启动的进程竞争CPU，更不要说还有后台作业，例如网络或收发电子邮件

的精灵进程。在讨论具体的调度算法之前，我们应该考虑一下调度程序要达到的目标。毕竟调度程序关注的是确定策略，而并不提供机制。一个好的调度算法应当考虑很多方面，其中可能有：                                                                   ??  1 公平  - 确保每个进程获得合理的CPU份额。??   2 有效  - 使CPU百分之百地忙碌。??   3 响应时间 - 使交互用户的响应时间尽可能短。  4 周转时间 - 使批处理用户等待输出的时间尽可能短。??    5 吞吐量 - 使每小时处理的作业数最多。  对这些目标稍加思考便会发现其中有矛盾之处。为了使交互用户的响应时间最短，应该对批处理作业不予调度（除了凌晨3点到6点，当用户休息时）。然而批处理用户可能不欢迎这种算法，它违背了条件4。可以证明（Kleinrock，1975）任何一个偏向某些类型作业的调度算法必将损害另一些作业。毕竟可利用的CPU时间是有限的。多给一个用户就要少给另一个用户，生活就是这样。调度程序必须面对的另一个麻烦是每个进程都不一样，而且不可预测。有些进程花费很多时间等待I/O，而另一些进程在允许的条件下将连续使用CPU达几个小时。 当调度程序启动运行某些进程时，它根本不知道进程在阻塞前要运行多久（阻塞可能是因为I/O、信号量、或者其他原因）。为了保证不让进程运行得太久，几乎所有的计算机都内置一个电子定时器或时钟，它将定期地发出中断，通常每秒钟50或60次（亦称作50或60赫兹，简写为Hz）。但在许多计算机上，操作系统能够根据需要将时钟频率设置成任意值。每发生一次时钟中断，操作系统都将运行，并决定当前进程是否应继续运行，还是它已经占用了足够长的CPU时间，应该暂停让其他进程运行。??允许将逻辑上可运行的进程暂时挂起的策略称作可剥夺调度(preemptive scheduling)，这与早期批处理系统使进程运行直到结束的方法正好相反。运行直到结束的调度方式称作非剥夺调度(nonpreemptive scheduling)。进程可在任意时刻被不加警告地挂起，以便让另一个进程运行。这导致了竞争条件以及防止竞争条件的信号量、管程、消息或其他复杂的方法。另一方面，允许一个进程运行它所希望的时间意味着一个计算圆周率小数点后边十亿位的进程将使其他进程永远得不到服务。所以尽管非剥夺调度算法简单且易于实现，但它通常不适于具有多个竞争用户的通用系统。另一方面，对于专用系统，如一个数据库服务器，主进程在收到请求时启动一个子进程并让其运行直到结束或阻塞则是很合理的。这种系统与通用系统的区别在于数据库系统中的所有进程都处于单个主进程的控制之下，该主进程知道各子进程将做什么，以及将花费的时间。  以下是几种调度算法：时间片轮转调度??、优先级调度、多重队列??、最短作业优先??、保证调度算法??、彩票调度算法??、实时调度??、 两级调度法??。 讨论系统进程的几个问题  分析作业、进程、线程三者之间的关系。  一个作业被调入内存执行时可能要为其创建多个进程，进程是资源分配的基本单位，一个进程可能对应若干个线程，线程是处理器调度的基本单位。用户要求计算机系统为其完成的计算任务的集合称为作业，分时用户在一次登入后进行的交互过程也常被看做一个作业。一般来说，作业时比进程大的一个概念，一个作业通常包含多个计算步骤，作业中一个相对独立的处理步骤称为一个作业步。当作业被作业调度程序选中并调入内存是，将按作业步创建相应进程。作业步骤之间具有顺序或并发关系。一个作业步通常可以由一个进程来完成，这样一个作业在内存处理时通常与多个进程相对应，即作业与进程具有一对多的关系。 进程是如何实现的？   操作系统维持着一张表格（一个结构数组）即进程表(process table)。 每个进程占用一个进程表项。该表项包含了进程的状态、它的程序计数器、栈指针、内存分配状况、打开文件状

态、计费和调度信息，以及其他在进程由运行态转到就绪态时必须保存的信息，只有这样才能使进程随后被再次启动，就象从未被中断过一样。 
进程优先级的设置  进程中有一个“设置优先级”，优先级是系统自动来调整的，一般无需我们自己调整。 不过遇到特殊情况，调整一下对电脑使用有好处。比如你想一边看电影一边打文字或干别的什么话，那么就调整那个电影播放器的进程，设置为“低于标准”，系统提示“可能会导致系统不稳定”，不要管它，选“是”继续。这样前台程序就会比后台程序（播放软件）优先，系统会让前台程序优先执行，前台程序空闲的时候再让后台程序满负荷工作。这样就可以充分占用前台程序剩下的系统资源，达到对系统资源的高效利用。 进程与病毒  “进程为应用程序的运行实例，是应用程序的一次动态执行。”我们可以简单地理解为：它是操作系统当前运行的执行程序。在系统当前运行的执行程序里包括：系统管理计算机个体和完成各种操作所必需的程序；用户开启、执行的额外程序，当然也包括用户不知道，而自动运行的非法程序（它们就有可能是病毒程序）。    危害较大的可执行病毒同样以“进程”形式出现在系统内部（一些病毒可能并不被进程列表显示，如“宏病毒”），那么及时查看并准确杀掉非法进程对于“手工杀毒有起着关键性的作用 操作系统如何打开进程列表？  要通过进程列表查看系统是否染毒，必须打开当前的执行程序进程列表，Microsoft的每种系统都有相应的打开方法，但能够显示的能力却因（系统）不同，有所差异：以Windows 2000/ XP/2003系统为例。Windows 2000、Windows XP、Windows 2003打开进程窗口的方式与Windows 9x系统相同，只是三键后打开的是“Windows 任务管理器”窗口，需要选择里面的“进程”项。Windows 2000系统只显示具体进程的全名，占用的内存量；Windows XP、Windows 2003系统相比Windows 2000会显示该进程归属于那个用户下，如操作系统所必须的基础程序，会在后面的“用户名”内显示为“SYSTEM”，由用户另外开启的程序则用户名为当前的系统登录用户名。为什么杀毒软件并不能全面的查找和杀掉病毒？首先，病毒防火墙是通过对程序进行反汇编，然后与自己的病毒库进行对比来查找病毒，如果病毒较新，而杀毒软件又未能及时升级便不能识别病毒。其次，杀毒软件在发现病毒后，如果是独立的可执行病毒程序，会选择直接删除的处理方式，而病毒如果被当作进程执行了，杀毒软件就无能为力了，因为它没有功能和权限先停止掉系统的这些进程，被当作进程执行的程序是不能被删除的（这也是大家在删除一个程序时，提示该程序正在被使用不能删除的原因）。所以在使用杀毒软件杀毒时，才会有杀毒完成后，又出现病毒提示的原因。  如果要准确的断定病毒，最好使用前面介绍的“Windows优化大师”来查看进程程序的源路径，如果是“C:\\windows\\system”下的一些未知的“EXE”那便极有病毒的可能性了。Windows XP和Windows 2003系统，进程后会有“用户名”的显示，病毒是不可能获得“SYSTEM”权限的，所以应注意“用户名”是当前登录用户的进程，一旦发现是病毒，可以立即“杀掉”。这里介绍两个技巧：    1．发现可疑进程后，利用Windows的查找功能，查找该进程所在的具体路径，通过路径可以知道该进程是否合法，譬如由路径“C:\\Program Files\\3721\\assistse.exe”知道该程序是3721的进程，是合法的。    2．在对进程是否病毒拿不定主意时，可以复制该进程的全名，如：“***.exe”到googl.com或baidu.com这样的全球搜查引擎上进行搜查，如果是病毒会有相关的介绍网页。  确定了该进程是病毒，首先应该杀掉该进程，对于Windows 9x系统，选中该进程后，点击下面的“结束任务”按钮，Windows 2000、Windows XP、Windows 2003系统则在进程上单击右键在弹出菜单上选择“结束任务”。“杀掉”进程后找到该进程的路径删除掉即可，完成后最好在进行一次杀毒，这样就万无一失了。    一次利用进程杀毒的具体过程是这样的：“通过进程名及路径判断是否病毒――杀掉进程――删除病毒程序”。